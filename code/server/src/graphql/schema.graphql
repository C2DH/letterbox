# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define custom Graphql types
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
enum DataItemType {
  company
  address
  country
  person
  message
}

union NodeItem @query(read: false, aggregate: false) =
  | Company
  | Address
  | Country
  | Person
  | Message

input NodeIdentification {
  type: DataItemType!
  id: ID!
}

#
# Graph DB schema
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

type RelaionshipProperties @relationshipProperties {
  deleted: Boolean
}

type Company
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  name: String!
  messages: [Message!]! @relationship(type: "CONTAINS", direction: IN)
  countries(skip: Int = 0, limit: Int = 50): [Country!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
  people(skip: Int = 0, limit: Int = 50): [Person!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
  addresses(skip: Int = 0, limit: Int = 50): [Address!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
}

type Country
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  name: String!
  messages: [Message!]! @relationship(type: "CONTAINS", direction: IN)
  companies(skip: Int = 0, limit: Int = 50): [Company!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
  people(skip: Int = 0, limit: Int = 50): [Person!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
  addresses(skip: Int = 0, limit: Int = 50): [Address!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
}

type Address
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  name: String!
  messages: [Message!]! @relationship(type: "CONTAINS", direction: IN)
  companies(skip: Int = 0, limit: Int = 50): [Company!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
  people(skip: Int = 0, limit: Int = 50): [Person!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
  countries(skip: Int = 0, limit: Int = 50): [Country!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
}

type Person
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  name: String!
  messages: [Message!]! @relationship(type: "CONTAINS", direction: IN)
  companies(skip: Int = 0, limit: Int = 50): [Company!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
  addresses(skip: Int = 0, limit: Int = 50): [Address!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
  countries(skip: Int = 0, limit: Int = 50): [Country!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      SKIP $skip
      LIMIT $limit
      """
    )
}

type Message
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  year: Int!
  filename: String!
  pageNumber: Int!
  message: String!

  # saving raw data of the CSV
  raw_company: String!
  raw_address: String!
  raw_people: [String!]
  raw_countries: [String!]
  raw_message: String!

  company: [Company!]!
    @relationship(type: "CONTAINS", direction: OUT, properties: "RelaionshipProperties")
  address: Address!
    @relationship(type: "CONTAINS", direction: OUT, properties: "RelaionshipProperties")
  persons: [Person!]!
    @relationship(type: "CONTAINS", direction: OUT, properties: "RelaionshipProperties")
  countries: [Country!]!
    @relationship(type: "CONTAINS", direction: OUT, properties: "RelaionshipProperties")
}

#
# Inputs
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

type ImportReport
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  count: Int!
  errors: [String!]
}
# Filters

enum FilterTypes {
  # Not respecting uppercase convention here as those values are required by client types
  number
  date
  keywords
  content
  boundingBox
  boolean
}

input NumberFilter {
  type: FilterTypes! # number
  min: Float # could be int or float client side...
  max: Float
}

input DateFilter {
  type: FilterTypes! # date
  min: Int # weird to see a number for a date... Date Filter looks like a Year Filter.
  max: Int
}

input KeywordsFilter {
  type: FilterTypes! # keywords
  values: [String!]!
}

input ContentFilter {
  type: FilterTypes! # content
  query: String!
}

input BoundingBoxFilter {
  type: FilterTypes! # boundingBox
  topLeft: [Float]
  bottomRight: [Float]
}

input BooleanFilter {
  type: FilterTypes! # boolean
  value: Boolean!
}

input SearchFilters {
  year: DateFilter
  years: DateFilter
  messageContent: ContentFilter
  companies: KeywordsFilter
  companyName: ContentFilter
  people: KeywordsFilter
  peopleName: ContentFilter
  addresses: KeywordsFilter
  addressName: ContentFilter
  countries: KeywordsFilter
}

# SORT

enum EsSortDirection {
  asc
  desc
}

input SortBy {
  field: String!
  direction: EsSortDirection!
}

# TOP INPUTS

enum MessageMetadata {
  company
  people
  country
  address
}
enum AddressMetadata {
  company
  people
  country
}
enum CountryMetadata {
  company
  people
  address
}
enum CompanyMetadata {
  people
  address
  country
}
enum PeopleMetadata {
  company
  address
  country
}

# RETURN TYPE

type SearchResults
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  total: Int!
  results: [NodeItem]!
  scrollId: String
}

type TopValue
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: String!
  label: String!
  count: Int!
}

type YearCountResult
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  year: Int
  count: Int
}

type CountResult
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  total: Int!
  byYear: [YearCountResult]
}

# QUERIES

type Query {
  "Search for Items using a set of filters"
  search(
    itemType: DataItemType!
    filters: SearchFilters!
    sortBy: [SortBy]
    limit: Int
    from: Int
    scrollTimeout: String
  ): SearchResults

  scroll(itemType: DataItemType!, scrollId: String!, scrollTimeout: String): SearchResults

  "Count Items respecting a set of filters, option to add count by year"
  countMessage(filters: SearchFilters!, byYear: Boolean): CountResult
  countCompany(filters: SearchFilters!, byYear: Boolean): CountResult
  countPeople(filters: SearchFilters!, byYear: Boolean): CountResult
  countCountry(filters: SearchFilters!, byYear: Boolean): CountResult
  countAddress(filters: SearchFilters!, byYear: Boolean): CountResult

  "Retrieve Top metadata values in Items which respect a set of filters"
  topMessageMetadata(
    metadataModel: MessageMetadata!
    filters: SearchFilters!
    limit: Int!
  ): [TopValue]
  topCompanyMetadata(
    metadataModel: CompanyMetadata!
    filters: SearchFilters!
    limit: Int!
  ): [TopValue]
  topPeopleMetadata(
    metadataModel: PeopleMetadata!
    filters: SearchFilters!
    limit: Int!
  ): [TopValue]
  topCountryMetadata(
    metadataModel: CountryMetadata!
    filters: SearchFilters!
    limit: Int!
  ): [TopValue]
  topAddressMetadata(
    metadataModel: AddressMetadata!
    filters: SearchFilters!
    limit: Int!
  ): [TopValue]

  #
  # Internal methods
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  _getMessageItems: [Message!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Message { id: id }) RETURN n AS result"
      columnName: "result"
    )
  _getCompanyItems: [Company!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Company { id: id }) RETURN n AS result"
      columnName: "result"
    )
  _getPersonItems: [Person!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Person { id: id }) RETURN n AS result"
      columnName: "result"
    )
  _getCountryItems: [Country!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Country { id: id }) RETURN n AS result"
      columnName: "result"
    )
  _getAddressItems: [Address!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Address { id: id }) RETURN n AS result"
      columnName: "result"
    )
}

type Mutation {
  """
  Create a graph in the database
  """
  import(fileNamePattern: String): ImportReport

  """
  Index the graph in the search engine
  """
  index: ImportReport

  """
  Create a new node on the specified message
  """
  createNode(messageId: ID!, type: DataItemType!, name: String!): NodeItem!

  """
  Rename a node value
  """
  renameNode(type: DataItemType!, id: ID!, name: String!): NodeItem!

  """
  Delete a node
  """
  deleteNode(type: DataItemType!, id: ID!): Boolean!

  """
  Change node's type
  """
  changeType(type: DataItemType!, id: ID!, newType: DataItemType!): NodeItem!

  """
  Split a node
  """
  splitNode(type: DataItemType!, id: ID!, values: [String!]!): [NodeItem!]!

  """
  Merge nodes
  """
  mergeNodes(nodes: [NodeIdentification!]!, type: DataItemType!, name: String!): NodeItem!
}
