# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define custom Graphql types
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
enum DataItemType {
  company
  address
  country
  person
  message
}

union NodeItem @query(read: false, aggregate: false) =
  | Company
  | Address
  | Country
  | Person
  | Message

input NodeIdentification {
  type: DataItemType!
  id: ID!
}

#
# Item Address
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

type Address
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  name: String!

  #
  # Message relationships
  #
  messagesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r]-(n:Message)
      WHERE NOT coalesce(r.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  messages(skip: Int = 0, limit: Int = 20): [Message!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r]-(n:Message)
      WHERE NOT coalesce(r.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.year ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Company relationships
  #
  companiesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  companies(skip: Int = 0, limit: Int = 20): [Company!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Country relationships
  #
  countriesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  countries(skip: Int = 0, limit: Int = 20): [Country!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # People relationships
  #
  peopleCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  people(skip: Int = 0, limit: Int = 20): [Person!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )
}

#
# Item Company
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

type Company
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  name: String!

  #
  # Message relationships
  #
  messagesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r]-(n:Message)
      WHERE NOT coalesce(r.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  messages(skip: Int = 0, limit: Int = 20): [Message!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r]-(n:Message)
      WHERE NOT coalesce(r.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.year ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Address relationships
  #
  addressesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  addresses(skip: Int = 0, limit: Int = 20): [Address!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Country relationships
  #
  countriesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  countries(skip: Int = 0, limit: Int = 20): [Country!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # People relationships
  #
  peopleCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  people(skip: Int = 0, limit: Int = 20): [Person!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )
}

#
# Item Country
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

type Country
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  name: String!

  #
  # Message relationships
  #
  messagesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r]-(n:Message)
      WHERE NOT coalesce(r.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  messages(skip: Int = 0, limit: Int = 20): [Message!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r]-(n:Message)
      WHERE NOT coalesce(r.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.year ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Address relationships
  #
  addressesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  addresses(skip: Int = 0, limit: Int = 20): [Address!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Company relationships
  #
  companiesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  companies(skip: Int = 0, limit: Int = 20): [Company!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # People relationships
  #
  peopleCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  people(skip: Int = 0, limit: Int = 20): [Person!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Person)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )
}

#
# Item Message
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

type Message
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  year: Int!
  filename: String!
  pageNumber: Int!
  message: String!

  # saving raw data of the CSV
  raw_company: String!
  raw_address: String!
  raw_people: [String!]
  raw_countries: [String!]
  raw_message: String!

  #
  # Address relationships
  #
  addressesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)-[r]->(n:Address)
      WHERE NOT coalesce(r.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  addresses(skip: Int = 0, limit: Int = 20): [Address!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)-[r]->(n:Address)
      WHERE NOT coalesce(r.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY n.result ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Company relationships
  #
  companiesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)-[r]->(n:Company)
      WHERE NOT coalesce(r.deleted, false)  AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  companies(skip: Int = 0, limit: Int = 20): [Company!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)-[r]->(n:Company)
      WHERE NOT coalesce(r.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY n.result ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Country relationships
  #
  countriesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)-[r]->(n:Country)
      WHERE NOT coalesce(r.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  countries(skip: Int = 0, limit: Int = 20): [Country!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)-[r]->(n:Country)
      WHERE NOT coalesce(r.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY n.result ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # People relationships
  #
  peopleCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)-[r]->(n:Person)
      WHERE NOT coalesce(r.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  people(skip: Int = 0, limit: Int = 20): [Person!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)-[r]->(n:Person)
      WHERE NOT coalesce(r.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )
}

#
# Item Person
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

type Person
  @node
  @query(read: true, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: ID! @unique
  name: String!

  #
  # Message relationships
  #
  messagesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r]-(n:Message)
      WHERE NOT coalesce(r.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  messages(skip: Int = 0, limit: Int = 20): [Message!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r]-(n:Message)
      WHERE NOT coalesce(r.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.year ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Address relationships
  #
  addressesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  addresses(skip: Int = 0, limit: Int = 20): [Address!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Address)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Company relationships
  #
  companiesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  companies(skip: Int = 0, limit: Int = 20): [Company!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Company)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )

  #
  # Country relationships
  #
  countriesCount: Int!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN COUNT(DISTINCT n) AS result
      """
    )
  countries(skip: Int = 0, limit: Int = 20): [Country!]!
    @cypher(
      columnName: "result"
      statement: """
      MATCH (this)<-[r1]-(:Message)-[r2]->(n:Country)
      WHERE NOT coalesce(r1.deleted, false) AND NOT coalesce(r2.deleted, false) AND NOT coalesce(n.deleted, false)
      RETURN DISTINCT n AS result
      ORDER BY result.name ASC
      SKIP $skip
      LIMIT $limit
      """
    )
}

#
# Inputs
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

type ImportReport
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  count: Int!
  errors: [String!]
}
# Filters

enum FilterTypes {
  # Not respecting uppercase convention here as those values are required by client types
  number
  date
  keywords
  content
  boundingBox
  boolean
}

input NumberFilter {
  type: FilterTypes! # number
  min: Float # could be int or float client side...
  max: Float
}

input DateFilter {
  type: FilterTypes! # date
  min: Int # weird to see a number for a date... Date Filter looks like a Year Filter.
  max: Int
}

input KeywordsFilter {
  type: FilterTypes! # keywords
  values: [String!]!
}

input ContentFilter {
  type: FilterTypes! # content
  query: String!
}

input BoundingBoxFilter {
  type: FilterTypes! # boundingBox
  topLeft: [Float]
  bottomRight: [Float]
}

input BooleanFilter {
  type: FilterTypes! # boolean
  value: Boolean!
}

input SearchFilters {
  year: DateFilter
  years: DateFilter
  messageContent: ContentFilter
  companies: KeywordsFilter
  companyName: ContentFilter
  people: KeywordsFilter
  peopleName: ContentFilter
  addresses: KeywordsFilter
  addressName: ContentFilter
  countries: KeywordsFilter
}

# SORT

enum EsSortDirection {
  asc
  desc
}

input SortBy {
  field: String!
  direction: EsSortDirection!
}

# TOP INPUTS

enum AggregationFields {
  companies
  people
  countries
  addresses
  years
  year
}

# RETURN TYPE

type SearchResults
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  total: Int!
  results: [NodeItem]!
  scrollId: String
}
type AggregateValue
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  id: String!
  label: String!
  count: Int!
}

type AggregateResults {
  total: Int!
  values: [AggregateValue!]!
}

type AggregateResults
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  total: Int!
  values: [AggregateValue!]!
}

type YearCountResult
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  year: Int
  count: Int
}

type CountResult
  @query(read: false, aggregate: false)
  @mutation(operations: [])
  @subscription(events: []) {
  total: Int!
  byYear: [YearCountResult]
}

# QUERIES

type Query {
  "Search for Items using a set of filters"
  search(
    itemType: DataItemType!
    filters: SearchFilters!
    sortBy: [SortBy]
    limit: Int
    from: Int
    scrollTimeout: String
  ): SearchResults

  scroll(itemType: DataItemType!, scrollId: String!, scrollTimeout: String): SearchResults
  aggregate(
    itemType: DataItemType!
    field: AggregationFields!
    query: String
    includes: String
    filters: SearchFilters
    size: Int
  ): AggregateResults!

  #
  # Internal methods
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  _getMessageItems: [Message!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Message { id: id }) RETURN n AS result"
      columnName: "result"
    )
  _getCompanyItems: [Company!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Company { id: id }) RETURN n AS result"
      columnName: "result"
    )
  _getPersonItems: [Person!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Person { id: id }) RETURN n AS result"
      columnName: "result"
    )
  _getCountryItems: [Country!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Country { id: id }) RETURN n AS result"
      columnName: "result"
    )
  _getAddressItems: [Address!]!
    @cypher(
      statement: "UNWIND $ids as id MATCH (n:Address { id: id }) RETURN n AS result"
      columnName: "result"
    )
}

type Mutation {
  """
  Create a graph in the database
  """
  import(fileNamePattern: String): ImportReport

  """
  Index the graph in the search engine
  """
  index: ImportReport

  """
  Create a new node on the specified message
  """
  createNode(messageId: ID!, type: DataItemType!, name: String!): NodeItem!

  """
  Rename a node value
  """
  renameNode(type: DataItemType!, id: ID!, name: String!): NodeItem!

  """
  Delete a node
  """
  deleteNode(type: DataItemType!, id: ID!): Boolean!

  """
  Change node's type
  """
  changeType(type: DataItemType!, id: ID!, newType: DataItemType!): NodeItem!

  """
  Split a node
  """
  splitNode(type: DataItemType!, id: ID!, values: [String!]!): [NodeItem!]!

  """
  Merge nodes
  """
  mergeNodes(nodes: [NodeIdentification!]!, type: DataItemType!, name: String!): NodeItem!
}
